#ifndef DOUBLEBUFFER_H
#defi:qne DOUBLEBUFFER_H

#include "Stencil.h"
#include "hls_target.h"
#include <hls_stream.h>

using hls::stream;

template<size_t X_SZ, size_t Y_SZ, size_t K_SZ, size_t Cin_SZ, size_t Cin_Iter, size_t Cout_Iter,
    size_t P_CIN, typename T>
class Doublebuffer_feature{
    private:
        T _db_0[(X_SZ + K_SZ - 1)*(Y_SZ + K_SZ -1)*Cin_SZ];
        T _db_1[(X_SZ + K_SZ - 1)*(Y_SZ + K_SZ -1)*Cin_SZ];
#pragma HLS aARRAY_PARTITION variable=_db_0 cyclic factor=8 dim=1
#pragma HLS aARRAY_PARTITION variable=_db_1 cyclic factor=8 dim=1

        bool flag;
        bool empty[2];
    public:
        void Doublebuffer_feature(){
            flag = false;
            empty[0] = true;
            empty[1] = true;
        }

        //generated by code generation
        void loadFromDRAM(T* _feature, T* _feature_buf, layerPara para, tilingID iter);//TODO come up with all the parameter needed by load
        void feedStream(T* _feature_buf, layerPara para, stream<PackedStencil<T, P_CIN, 1, 1, 1>> & out_stream);// TODO come up with all the parameter needed by feed

        void call(T* _feature, stream<PackedStencil<T, P_CIN, 1, 1, 1>> &out_stream,
                layerPara para, tilingID iter){
#pragma HLS INLINE
            if(flag == false){
                this->loadFromDRAM(_feature, _db_0, para, iter);
                this->feedStream(_db_1, para, out_stream);
                empty[0] = false;
            }
            else{
                this->loadFromDRAM(_feature, _db_1, para, iter);
                this->feedStream(_db_0, para, out_stream);
                empty[1] = false;
            }

            flag = 1 - flag;
        }

        void call_finish(T* _feature, layerPara para, stream<PackedStencil<T, P_CIN, 1, 1, 1>> &out_stream){
            if(this->flag == false)
                this->feedStream(_db_1, para, out_stream);
            else
                this->feedStream(_db_0, para, out_stream);
        }
}


template<size_t X_SZ, size_t Y_SZ, size_t K_SZ, size_t Cin_SZ, size_t Cout_SZ, size_t Cin_Iter, size_t Cout_Iter,size_t P_CIN, size_t P_COUT, typename T>
class Doublebuffer_weight{
    private:
        T _db_0[Cout_SZ][Cin_SZ*K_SZ*K_SZ];
        T _db_1[Cout_SZ][Cin_SZ*K_SZ*K_SZ];
#pragma HLS ARRAY_PARTITION variable=_db_0 cyclic factor=8 dim=1
#pragma HLS ARRAY_PARTITION variable=_db_0 cyclic factor=8 dim=2
#pragma HLS ARRAY_PARTITION variable=_db_1 cyclic factor=8 dim=1
#pragma HLS ARRAY_PARTITION variable=_db_1 cyclic factor=8 dim=2
        bool flag;
        bool empty[2];

    public:
        void Doublebuffer_weight(){
            flag = false;
            empty[0] = true;
            empty[1] = true;
        }

        void loadFromDRAM(T* _weight, T* _weight_buf, layerPara para, tilingID iter);//TODO add parameter
        void feedStream(T* _weight_buf, layerPara para, stream<PackedStencil<T, P_CIN, P_COUT, 1, 1>> & out_stream);//TODO add parameter

        void call(T* _weight, stream<PackedStencil<T, P_CIN, P_COUT, 1, 1>> &out_stream,
                layerPara para, tilingID iter){
#pragma HLS INLINE
            if(flag == false){
                this->loadFromDRAM(_weight, _db_0, para, iter);
                this->feedStream(_db_1, para, out_stream);
                empty[0] = false;
            }
            else{
                this->loadFromDRAM(_weight, _db_1, para, iter);
                this->feedStream(_db_0, para, out_stream);
                empty[1] = false;
            }

            flag = 1 - flag;
        }

        void call_finish(T* _weight_buf, layerPara para, stream<PackedStencil<T, P_CIN, P_COUT, 1, 1>> & out_stream){
            if(flag == false)
                this->feedStream(_db_1, para, iter, out_stream);
            else
                this->feedStream(_db_0, para, iter, out_stream);
        }
}


template<size_t X_SZ, size_t Y_SZ, size_t K_SZ, size_t Cin_SZ, size_t Cout_SZ, size_t Cin_Iter, size_t Cout_Iter,size_t P_CIN, size_t P_COUT, typename T>
class Doublebuffer_psum{
    private:
        T _db_0[Cout_SZ * X_SZ * Y_SZ];
        T _db_1[Cout_SZ * X_SZ * Y_SZ];
#pragma HLS ARRAY_PARTITION variable=_db_0 cyclic factor=8 dim=1
#pragma HLS ARRAY_PARTITION variable=_db_1 cyclic factor=8 dim=1
        bool flag;
        bool empty[2];
        //TODO: add a self counting tilingID here.
        tilingID write_back_iter;

    public:
        void Doublebuffer_psum(){
            flag = false;
            empty[0] = true;
            empty[1] = true;
        }


        void iter_retrive(struct tilingID* id, struct layerPara para){
#pragma HLS inline off
            if (id->tilingIDc_i > 0){
                id->tilingIDc_i -= 1;
                //return false;
            }
            else if (id->tilingIDc_o > 0){
                id->tilingIDc_o -= 1;
                id->tilingIDc_i = para.Cin_n - 1;
                //return false;
            }
            else if(id->tilingIDx > 0){
                id->tilingIDx -= 1;
                id->tilingIDc_o = para.Cout_n - 1;
                id->tilingIDc_i = para.Cin_n - 1;
                //return false;
            }
            else //if(id->tilingIDy > 0)
            {
                id->tilingIDy -= 1;
                id->tilingIDx = para.X_n - 1;
                id->tilingIDc_o = para.Cout_n - 1;
                id->tilingIDc_i = para.Cin_n - 1;
                //return false;
            }
            //else
                //return true;
}

        void receive_stream(stream<PackedStencil<T, P_COUT, 1, 1, 1>> in_stream, T* _psum_buf, layerPara para);//TODO add parameter, in_stream, psum_buf
        void writeToDRAM(T* _output, T* _psum_buf, layerPara para, tilingID iter);//TODO add parameter, psum_buf, _output

        void call(stream<PackedStencil<T, P_COUT, 1, 1, 1>> in_stream, T* _output, layerPara para, tilingID iter){
#pragma HLS INLINE
            if(flag == false){
                receive_stream(in_stream, _db_0, para);
                writeToDRAM(_output, _db_1, para, iter);
                empty[0] = false;
            }
            else{
                receive_stream(in_stream, _db_1, para);
                writeToDRAM(_output, _db_0, para, iter);
                empty[1] = false;
            }

            flag = 1 - flag;
    }

        void call_finish(T* _output, layerPara para, tilingID iter){
#pragma HLS INLINE
            if(flag == false)
                writeToDRAM(_output, _db_1, para, iter);
            else
                writeToDRAM(_output, _db_0, para, iter);
        }
}
#endif
